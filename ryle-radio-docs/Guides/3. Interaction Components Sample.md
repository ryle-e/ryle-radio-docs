This sample is all about the interaction components: RadioObservers and RadioInteractors. It uses a basic scene and radio, but more complex functionality.

---
## Accessing the sample
First, install the sample through Unity's Package Manager. Navigate to `RyleRadio/Samples/InteractionComponents`, and open `MainScene`. It should look like this: 
![[Pasted image 20251021001937.png]]

## Description
### RadioData
Let's have a quick look at the RadioData we're using in this scene. It's similar to, but has some significant differences from, past RadioData objects from other samples.
#### music
Ol' reliable! This track just plays a song as we're used to- nothing unusual on this one.
#### track_sfx
![[Pasted image 20251018224534.png]]
This track is normal, except for one difference- Play on Init is toggled off! This means that the track will never play automatically or on its own- we have to manually play this track. We'll find out where that happens in a little while!
#### track_sfx_silence
Now this is a strange one. This is a silent track that plays no noise. Why is it here, then?
This silent track is used to attenuate the static audio even when there's no sound playing on track_sfx above. 
Because we have to manually start the audio in track_sfx, there's going to be an amount of time where nothing is playing through that track. Usually, audio that's attenuating to the volume of a track that isn't playing anything will behave as if the track isn't there. We don't want this here, because that would make the static sound as if it's getting louder and quieter constantly! In order to prevent it from happening, then, we use this silent track to permanently lower the volume of the attenuating static track when it's in the same area as this track and track_sfx.
In short- we use silence to keep the static quiet when track_sfx isn't playing anything.
#### station_sfx
Same as track_sfx, but instead of a single audio track we use a Station. The station is identical to [[1. Basic Radio Sample#station_sfx|station_sfx]] from [[1. Basic Radio Sample]].
#### station_sfx_silence
Silence for the same reason as [[#track_sfx_silence]]- keeping the static quiet when nothing is playing on station_sfx.
#### static
The same as usual- run of the mill static with a high attenuation value so that it gets quieter when another track (including a silent one) is playing.

### Scene
With that out of the way, let's have a look at the scene for this sample.
Our first object is our typical Radio. It uses the model as per usual, and a RadioOutput as we're used to.
Then we start looking at the more unusual objects- our Observers and Interactors. We should go over Interactors first, otherwise some actions of the Observers won't make sense :)

### Interactors
**RadioInteractor**s are very unusual components compared to those we've used previously. They don't actually do anything on their own- they're more of a gateway for other components and code to interact with your radios. You can reference them in events (such as those in Observers) and from custom code to do various radio-related actions, namely playing, pausing, stopping, and resetting tracks!
![[Pasted image 20251021000742.png]]
With that being said, they do have values editable in the inspector that are worth explaining- the variables under Advanced Settings are a lot more niche, so those have been relegated to the code documentation.
#### Output
Unlike other components, Interactors and Observers reference the RadioOutput component rather than its RadioData (this is so that it reponds to only one Output, not all of them)! Assign the Output you want to be performing actions on here.
#### Affected Tracks
We're familiar with this option from our Broadcasters and Insulators- we choose here which tracks we want the component to influence.
For our interactors, we're choosing which tracks we want them to play, pause, etc.

Okay, so how do we use the Interactor? What does it *do*?
### How we use Interactors and What they Do
Well I'm glad you asked!
In order to make an Interactor actually do something, we need some way to call it- this is usually in the form of a UnityEvent. There's a bunch of these in RadioObservers, but in this sample scene we have some demo ones on the `Events` object. Click on that, open the dropdowns, and you should see the following:
![[Pasted image 20251021002219.png]]
Now, we make stuff! Yep, this sample's interactive. How wonderful!
First, select a key on the dropdown. It can be anything, but given how awful Unity's selection option is for KeyCodes (I'm sure it's at least part of the reason they're pushing away KeyCodes to begin with), one of the F1 - F4 keys should suffice. Then, add a new entry in the event (the inner plus symbol).
![[Pasted image 20251021003254.png]]
Next, drag one of the Interactor objects in the scene into the "None (Object)" box- this points the event towards that object.
![[Pasted image 20251021003527.png]]
Now, we choose the methods to call on the interactor- we choose what to make it do.
Every interactor has (at least) four methods available to us in events and code: PlayLoop, PlayOneShot, Pause/Unpause/FlipPause, Stop and Reset. For a very quick overview:
**PlayLoop** plays a track. Once that track reaches the end, it'll loop back to the beginning. Only tracks with AudioClips can reach the end, but it's better to use this for everything unless you specifically need it to be a OneShot.
**PlayOneShot** plays a track. Once that track reaches the end, it stops.
**Pause** pauses a track, temporarily stopping it from playing. **Unpause** lifts the pause on a track, resuming its playing. **FlipPause** pauses the track if it's not paused, and unpauses it if it is.
**Stop** makes the track stop playing immediately- even if it's a Loop. You can't unpause it after it's been stopped!
**Reset** makes the track go back to the beginning, and clears the recently played tracks if it's.

### Observers
**RadioObserver**s are a component quite different to those we're used to. Rather than altering the radio and how it plays, the observer makes things happen in *response* to things on the radio. Let's check out the observer in the scene.
![[Pasted image 20251019001706.png]]
RadioObservers have two main variables at the top- the RadioOutput it is linked to, and the tracks that it watches. Think of an observer like, well, an observer- it watches for certain changes or events, then alerts others in response. You can specify in the Affected Tracks variable which tracks it watches for those changes on. More importantly, though, are the events! We'll go through them one by one. Keep an eye on the UI in the scene, with the line representing tune- I'll link back the events each to their part of the UI!
#### Event 1: Output Volume
![[Pasted image 20251019001514.png]]
This event is watching a value called Output Volume- this is the volume of the track according to the radio's tune, broadcast power, and insulation- but not the track's gain. It watches for the output volume to be above 0.1, then, which would mean it's at least partially audible.
In the scene, this event is represented by the blue UI line and the blue light- when the output volume is above 0.1, the light will turn on!
You may also notice that the light turns on a little bit further into the track than the blue line suggests- this is because (admittedly confusingly) the blue line shows the area where the track plays, not necessarily where its volume is above 0.1. 

If we hit the Show Events toggle, though, we can see all the UnityEvents that this is linked to- OnTrigger the blue light will be turned on and its material switched to a brighter one, and OnEnd the reverse will happen. 
#### Event 2: Output Volume
![[Pasted image 20251019001529.png]]
Just like the previous event, this one is watching for the volume of the affected track(s) to be above a certain threshold. In this case, it's waiting for it to be above 0.8- this means both the blue and green lights will be turned on when the tune allows the track to be loud enough.

The events on this one are very similar to Event 1- they turn on and off the green light and its brighter material.
#### Event 3: Output Tune
This event, though, watches for the output tune of the radio- the affected track has no input here. When the RadioOutput's tune value is within the specified range (300 - 350), it'll will be triggered regardless of which track is playing!

The event here calls a method on one of our Interactor objects (that we will look at closer soon)