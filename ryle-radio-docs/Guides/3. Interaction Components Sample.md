This sample is all about the interaction components: RadioObservers and RadioInteractors. It uses a basic scene and radio, but more complex functionality.

---
## Accessing the sample
First, install the sample through Unity's Package Manager. Navigate to `RyleRadio/Samples/InteractionComponents`, and open `MainScene`. It should look like this: 
![[Pasted image 20251018223258.png]]

## Description
### RadioData
Unlike the last two samples, we'll be looking at the RadioData object before we look at the scene for this one- a lot of what goes on in the scene won't make sense without the RadioData in mind! Let's go through the tracks- many of them are the same as tracks we've seen in past samples.
#### music
Ol' reliable! This track just plays a song as we're used to- nothing unusual on this one.
#### track_sfx
![[Pasted image 20251018224534.png]]
This track is normal, except for one difference- Play on Init is toggled off! This means that the track will never play automatically or on its own- we have to manually play this track. We'll find out where that happens in a little while!
#### track_sfx_silence
Now this is a strange one. This is a silent track that plays no noise. Why is it here, then?
This silent track is used to attenuate the static audio even when there's no sound playing on track_sfx above. 
Because we have to manually start the audio in track_sfx, there's going to be an amount of time where nothing is playing through that track. Usually, audio that's attenuating to the volume of a track that isn't playing anything will behave as if the track isn't there. We don't want this here, because that would make the static sound as if it's getting louder and quieter constantly! In order to prevent it from happening, then, we use this silent track to permanently lower the volume of the attenuating static track when it's in the same area as this track and track_sfx.
In short- we use silence to keep the static quiet when track_sfx isn't playing anything.
#### station_sfx
Same as track_sfx, but instead of a single audio track we use a Station. The station is identical to [[1. Basic Radio Sample#station_sfx|station_sfx]] from [[1. Basic Radio Sample]].
#### station_sfx_silence
Silence for the same reason as [[#track_sfx_silence]]- keeping the static quiet when nothing is playing on station_sfx.
#### static
The same as usual- run of the mill static with a high attenuation value so that it gets quieter when another track (including a silent one) is playing.

### Scene
With that out of the way, let's have a look at the scene for this sample.
Our first object is our typical Radio. It uses the model as per usual, and a RadioOutput as we're used to.
Then we start looking at the more unusual objects- our Observers and Interactors. We should go over Interactors first, otherwise some actions of the Observers won't make sense :)

### Interactors
**RadioInteractor**s are very unusual components compared to those we've used previously. They don't actually do anything on their own- they're more of a gateway for other components and code to interact with your radios.
![[Pasted image 20251020232602.png]]
With that being said, they do have values editable in the inspector that are worth explaining.
#### Output
Unlike other components, Interactors and Observers reference the RadioOutput component rather than its RadioData! This is so that it doesn't respond to events happening on every RadioOutput at once- it means you can be listening for changes on one specific 

### Observers
**RadioObserver**s are a component quite different to those we're used to. Rather than altering the radio and how it plays, the observer makes things happen in *response* to things on the radio. Let's check out the observer in the scene.
![[Pasted image 20251019001706.png]]
RadioObservers have two main variables at the top- the RadioOutput it is linked to, and the tracks that it watches. Think of an observer like, well, an observer- it watches for certain changes or events, then alerts others in response. You can specify in the Affected Tracks variable which tracks it watches for those changes on. More importantly, though, are the events! We'll go through them one by one. Keep an eye on the UI in the scene, with the line representing tune- I'll link back the events each to their part of the UI!
#### Event 1: Output Volume
![[Pasted image 20251019001514.png]]
This event is watching a value called Output Volume- this is the volume of the track according to the radio's tune, broadcast power, and insulation- but not the track's gain. It watches for the output volume to be above 0.1, then, which would mean it's at least partially audible.
In the scene, this event is represented by the blue UI line and the blue light- when the output volume is above 0.1, the light will turn on!
You may also notice that the light turns on a little bit further into the track than the blue line suggests- this is because (admittedly confusingly) the blue line shows the area where the track plays, not necessarily where its volume is above 0.1. 

If we hit the Show Events toggle, though, we can see all the UnityEvents that this is linked to- OnTrigger the blue light will be turned on and its material switched to a brighter one, and OnEnd the reverse will happen. 
#### Event 2: Output Volume
![[Pasted image 20251019001529.png]]
Just like the previous event, this one is watching for the volume of the affected track(s) to be above a certain threshold. In this case, it's waiting for it to be above 0.8- this means both the blue and green lights will be turned on when the tune allows the track to be loud enough.

The events on this one are very similar to Event 1- they turn on and off the green light and its brighter material.
#### Event 3: Output Tune
This event, though, watches for the output tune of the radio- the affected track has no input here. When the RadioOutput's tune value is within the specified range (300 - 350), it'll will be triggered regardless of which track is playing!

The event here calls a method on one of our Interactor objects (that we will look at closer soon)